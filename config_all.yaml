# Which registers are attacker-controlled.
# Note that we generally consider everything controlled,
# and later filter the gadgets based on the "Requirements" column.
controlled_registers:
  - rax
  - rbx
  # Argument registers
  - rdi
  - rsi
  - rdx
  - rcx
  - r8
  - r9
  # General purpose
  - r10
  - r11
  - r12
  - r13
  - r14
  - r15

# What portion of the stack is attacker-controlled.
controlled_stack:
  # 20 64-bit values
  - start: 0
    end: 160
    size: 8

# Verbosity of the logging output.
# Level 0: no output
# Level 1: coarse-grained log
# Level 2: fine-grained log (debug)
LogLevel: 1

# Forward stored values to subsequent loads.
STLForwarding: True

# Timeout of the Z3 solver when evaluating constraints.
Z3Timeout: 10000 # ms = 10s

# Maximum number of basic blocks to explore for each entrypoint.
MaxBB: 5

# Distribute left shifts over + and -.
DistributeShifts: True

# Also look for tainted function pointers (i.e. dispatch gadgets).
TaintedFunctionPointers: True

# Also output "Half-Spectre" gadgets, a.k.a MDS gadgets.
# https://download.vusec.net/papers/halfspectre_sp25.pdf
HalfSpectre: False

# If this is true, any exception thrown during scanning will cause immediate
# abort of the execution. This is not desirable during long runs on e.g. the
# Linux Kernel because we want the scanning to continue to the next gadget
# if, for some reason, the execution crashes on a specific gadget.
# It can be however useful for debugging purposes.
CrashOnExceptions: False

# Should we analyse the transmissions only after scanning the whole gadget,
# or should we try to output transmissions as soon as they are found?
# This has consequences on interrupting, e.g., if you analyse only _after_ scanning
# you won't have any outputted transmission in case of  e.g.timeouts.
AnalyzeDuringScanning: True
