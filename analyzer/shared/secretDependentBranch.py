"""
Secret Dependent Branch object.
"""

import claripy

from . import utils
from .transmission import Transmission, TransmissionComponent, TransmissionExpr, component_to_dict


class SecretDependentBranchExpr(TransmissionExpr):
    """
    Symbolic expression representing a potential secret dependent branch.
    Generated by the Scanner, is then later split into actual
    SecretDependentBranch objects by the SecretDependentBranchAnalysis.
    """
    pass


class SecretDependentBranch(Transmission):
    """
    Object that represents a Spectre transmission gadget, via a secret
    dependent branch, with all the properties that can be extracted by our
    analysis.
    """

    sdb_expr: claripy.BVS
    cmp_value: TransmissionComponent
    controlled_cmp_value: TransmissionComponent
    cmp_operation: str

    def __init__(self, expr):
        self.sdb_expr = expr
        self.cmp_value = TransmissionComponent()
        self.controlled_cmp_value = TransmissionComponent()
        self.cmp_operation = expr.op

    def __repr__(self):
        return f"""
        uuid: {self.uuid}
        name: {self.name}
        address: {hex(self.address)}
        pc: {hex(self.pc)}
        secret_load_pc: {hex(self.secret_load_pc)}
        transmitter: {self.transmitter}
        cmp_operation: {self.cmp_operation}

        secret_dependent_branch:
            {self.sdb_expr}
        |-- transmission:
            {self.transmission}
          |-- base:
            {self.base}
                |-- secret-independent part:
                {self.independent_base}
          |-- transmitted secret:
            {self.transmitted_secret}
          |-- secret addr:
            {self.secret_address}
          |-- secret val:
            {self.secret_val}
        |-- cmp_value:
            {self.cmp_value}
                |-- controlled part:
                {self.controlled_cmp_value}


        branches: {utils.ordered_branches(self.branches)}
        bbls: {[hex(x) for x in self.bbls]}
        branch requirements: {self.branch_requirements}

        constraints: {utils.ordered_constraints(self.constraints)}
        constraint requirements: {self.constraint_requirements}

        all requirements: {self.all_requirements}
        all requirements_w_branches: {self.all_requirements_w_branches}

        inferable_bits:
            {self.inferable_bits}

        aliases: {self.aliases}
        n_instr: {self.n_instr}
        n_dependent_loads: {self.max_load_depth}
        properties:\n{self.dump_properties()}
        """

    def to_dict(self):
        d = super().to_dict()

        d['sdb_expr'] = self.sdb_expr
        d['cmp_operation'] = self.cmp_operation
        d['cmp_value'] = component_to_dict(self.cmp_value)
        d['controlled_cmp_value'] = component_to_dict(
            self.controlled_cmp_value)

        return d
